# MyDistributedLock
基于redis的分布式锁的实现

要做到哪几点：  
1、防死锁；  
2、防误删；  
3、可重入；  
4、自动续期；  

什么情况下会发生死锁？  
若锁不会过期，当获得锁的进程突然宕机导致未执行解锁流程，那这个锁就无法再被其它进程获取，这就死锁了。  

如何防止死锁？  
可以给锁加上过期时间，假如发生以上极端情况，在锁过期后，别的进程还是可以获取到该锁的。  

设置锁的过期时间的话，假如锁过期了业务还未跑完，怎么办？  
这个时候就需要给锁的过期时间加上自动续期的逻辑。在锁到了过期时间时，自动为这把锁的过期时间续期；  

自动续期如何实现的呢？  
可以起一个定时器，在锁将要过期前，通过expire命令给锁设置新的过期时间；  

过期时间的设置有何讲究？  
过期时间设置和业务处理时间相比不能太短，否则就会导致频繁地续期，会影响性能。  
和业务处理时间相比也不能太长，否则持有锁的进程宕机后别的进程要等待太长的时间才能获取锁。  

在什么情况下会出现误删的问题？  
1、在释放锁之前，若不判断是否是自己持有的锁就删除，然后未获取锁的进程在获取锁时发生了异常导致执行到了finally里的解锁逻辑。  
2、若锁设置了过期时间且未做自动续期的话，假如业务处理还未完成锁就过期了，那么此时锁就会被其它进程获取。但原来获取锁的业务进程不知道锁已被别的进程获取了，业务执行末尾执行了解锁逻辑。  
3、假如判断完是自己持有的锁后，在删锁之前，此时锁的过期时间刚好到了，然后又被别的进程获取到了锁，这样后续的删锁就是一个误删操作。  

如何防误删？  
1、在释放锁前首先判断是否是自己持有锁，只有是自己持有的锁才去删；  
2、判断是否自己持有锁和删锁的2步动作必须要保证原子性，可以通过把这两步写在lua脚本里来实现。  

如何实现可重入？  
在记录是谁获取锁的同时顺便记录这个进程获取锁的次数，每获取一次就加1。释放锁的时候，这个次数减1，若次数减到0，则正式进行删锁操作。  


redis分布式锁使用场景：
1、防超卖：
就是获取到分布式锁后再对库存进行扣减。
2、缓存击穿：
实际上解决缓存击穿问题的解决方案和懒汉单例模式中的处理逻辑有相似之处，都需要用到DCL技巧。单例中的锁是jvm的本地锁，而缓存击穿的锁则是redis实现的分布式锁。单例中获取锁后是为了实例化单例对象，而缓存击穿获取锁后是为了从数据库中查出数据并将数据放入缓存中。获取锁后同样需要进行第二次检查，单例中再次检查的是单例对象是否已经实例化，缓存击穿检查的是缓存中是否已存在数据。
